/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pepbuilderj;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * Original DSSP is provided by Coos Baakman with following license.
*Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

 * @author kimidori
 */
public class DSSPJ {
	//From dssp 3.0.0
	//http://swift.cmbi.ru.nl/gv/dssp/
	public static final double kSSBridgeDistance = 3.0,
	kMinimalDistance = 0.5,
	kMinimalCADistance = 9.0,
	kMinHBondEnergy = -9.9,
	kMaxHBondEnergy = -0.5,
	kCouplingConstant = -27.888,  //  = -332 * 0.42 * 0.2
	kMaxPeptideBondLength = 2.5;

	public static final double 
	kRadiusN = 1.65,
	kRadiusCA = 1.87,
	kRadiusC = 1.76,
	kRadiusO = 1.4,
	kRadiusSideAtom = 1.8,
	kRadiusWater = 1.4;
	/*
	
enum MSecondaryStructure
{
  loop,    //' '
  alphahelix,  // H
  betabridge, // B
  strand,    // E
  helix_3,  // G
  helix_5,  // I
  turn,    // T
  bend    // S
};

	*/
	public static final int SS_LOOP = 0;
	public static final int SS_ALPHAHELIX = 1;
	public static final int SS_BETABRIDGE = 2;
	public static final int SS_STRAND = 3;
	public static final int SS_HELIX3 = 4;
	public static final int SS_HELIX5 = 5;
	public static final int SS_TURN = 6;
	public static final int SS_BEND = 7;
	
	
	
	public static void calcHBounds(DSSPChain chain){
		for(int ii = 0;ii < chain.residues.size();ii++){
			DSSPResidue r1 = chain.residues.get(ii);
			for(int jj = 1;jj < chain.residues.size();jj++){
				DSSPResidue r2 = chain.residues.get(jj);
				r1.checkDonor(r2);
				r1.checkAcceptor(r2);
				r2.checkDonor(r1);
				r2.checkAcceptor(r1);
			}
		}
	}
	
	public static void calcHelix(DSSPChain chain){
		for(int ii = 0;ii < 3;ii++){
			for(int jj = 0;jj < chain.residues.size();jj++){
				DSSPResidue r = chain.residues.get(jj);
				if(r.isDonorOf(chain.residues.get(jj+3+ii))){
					r.helixStart[ii] = true;
				}else{
					r.helixStart[ii] = false;
				}
			}
		}
		int helixcode[] = {DSSPJ.SS_HELIX3,DSSPJ.SS_ALPHAHELIX,DSSPJ.SS_HELIX5};
		for(int helixshift = 0;helixshift < 3;helixshift++){
			for(int jj = 0;jj < chain.residues.size();jj++){
				DSSPResidue r = chain.residues.get(jj);
				if(r.helixStart[helixshift]){
					boolean dflag = true;
					for(int kk = jj+1;kk < jj+helixshift+3;kk++){
						if(chain.residues.get(kk-1).hasChainBreak){
							dflag = false;
							break;
						}
						int dss = chain.residues.get(kk).getSecondaryStructure();
						if(dss == DSSPJ.SS_LOOP || dss == helixcode[helixshift]){
						}else{
							dflag = false;
							break;
						}
					}
					for(int kk = jj+1;kk < jj+helixshift+3;kk++){
						chain.residues.get(kk).setSecondaryStructure( helixcode[helixshift]);
					}
				}
			}
		}

	}
	
	
	
	//helix (G, H and I), strand (E and B) and loop (S, T, and C, where C sometimes is represented also as blank space)
	public static double calcHBoundEnergy(PDBResidue don,PDBResidue acc){
		double distho = don.getN_H().distance(acc.getO());
		double disthc = don.getN_H().distance(acc.getC());
		double distnc = don.getN().distance(acc.getC());
		double distno = don.getN().distance(acc.getO());
		double energy = kMinHBondEnergy;
		if (distho < kMinimalDistance
		|| disthc < kMinimalDistance
		|| distnc < kMinimalDistance
		|| distno < kMinimalDistance){
	      energy = kMinHBondEnergy;
		}else{
			energy = kCouplingConstant / distho - kCouplingConstant / disthc + kCouplingConstant / distnc - kCouplingConstant / distno;
		}
		energy = Math.round(energy * 1000) / 1000;
		if (energy < kMinHBondEnergy){
			energy = kMinHBondEnergy;
		}
		return energy;
	}
	
	
	public static void main(String[] args){
		PDBData pdb = PDBData.loadPDBFile("");
		for(String c:pdb.chains.keySet()){
			PDBChain cc = pdb.chains.get(c);
			DSSPChain dchain = new DSSPChain(cc);
			for(int ii = 0;ii < cc.residues.size();ii++){
				PDBResidue r = cc.residues.get(ii);
				if(r.isLigand()){
					continue;
				}
				if(r.isMissing()){
					continue;
				}
				
			}
		}
	}
	
}

class DSSPChain{
	ArrayList<DSSPResidue> residues = new ArrayList<>();
	PDBChain chain = null;
	DSSPChain(PDBChain c){
		chain  =c;
	}
	public boolean hasChainBreak(int index1,int index2){
		for(int ii = index1;ii < index2;ii++){
			if(residues.get(ii).hasChainBreak){
				return true;
			}
		}
		return false;
	}
}


class DSSPResidue{
	PDBResidue residue = null;
	ArrayList<HBoundState> asDonor = new ArrayList<>();
	ArrayList<HBoundState> asAcceptor = new ArrayList<>();
	
	
	boolean hasChainBreak = false;
	//3 ,4 ,5
	boolean[] helixStart = {false,false,false};
	int ss = DSSPJ.SS_LOOP;
	DSSPResidue(PDBResidue p){
		residue = p;
		for(int ii = 0;ii < 2;ii++){
			asDonor.add(new HBoundState(this,null,1000));
			asAcceptor.add(new HBoundState(this,null,1000));
		}
	}
	
	
	public void setSecondaryStructure(int s){
		ss = s;
	}
	public int getSecondaryStructure(){
		return ss;
	}
	public boolean isDonorOf(DSSPResidue d){
		if(asDonor.get(0).acceptor == d && asDonor.get(0).energy < DSSPJ.kMaxHBondEnergy){
			return true;
		}
		
		if(asDonor.get(1).acceptor == d && asDonor.get(1).energy < DSSPJ.kMaxHBondEnergy){
			return true;
		}
		return false;
	}
	
	public boolean isAcceptorOf(DSSPResidue d){
		if(asAcceptor.get(0).donor == d && asAcceptor.get(0).energy < DSSPJ.kMaxHBondEnergy){
			return true;
		}
		
		if(asAcceptor.get(1).donor == d && asAcceptor.get(1).energy < DSSPJ.kMaxHBondEnergy){
			return true;
		}
		return false;
	}
	
	
	
	public void checkDonor(DSSPResidue donorcandidate){
		double en = DSSPJ.calcHBoundEnergy(donorcandidate.residue,this.residue);
		if(en < this.asAcceptor.get(1).energy){
			this.asAcceptor.get(1).energy = en;
			this.asAcceptor.get(1).donor = donorcandidate;
		}
		Collections.sort(this.asAcceptor,new HBoundStateComparator());
	}
	
	public void checkAcceptor(DSSPResidue acceptorcandidate){
		double en = DSSPJ.calcHBoundEnergy(acceptorcandidate.residue,this.residue);
		if(en < this.asDonor.get(1).energy){
			this.asDonor.get(1).energy = en;
			this.asDonor.get(1).donor = acceptorcandidate;
		}
		Collections.sort(this.asDonor,new HBoundStateComparator());
	}
	
	
	
	
}

class HBoundState{
	double energy = 10000;
	DSSPResidue donor = null;
	DSSPResidue acceptor = null;
	HBoundState(DSSPResidue d,DSSPResidue a,double e){
		donor = d;
		acceptor = a;
		energy = e;
	}

}


class HBoundStateComparator implements Comparator<HBoundState>{
	@SuppressWarnings("unchecked")
	public int compare(HBoundState arg1, HBoundState arg2){
		
		if(arg1.energy < arg2.energy ){
			return -1;
		}
		if(arg1.energy == arg2.energy){
			return 0;
		}
			return 1;
	}
	
}